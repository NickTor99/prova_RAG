from pydantic import (
    BaseModel,
    Field,
    field_validator,
    model_validator,
    ConfigDict
)
from typing import Optional, Literal
from enum import Enum
import re


class VulnerabilitySeverity(str, Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


class BoolVulnerability(BaseModel):
    """
    Enhanced vulnerability assessment model for Pydantic v2+.
    Uses modern validators with strict type checking and security validation.
    """
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "name": "Unchecked Transaction Fee",
                "description": "No validation of Txn.fee() found in payment handlers",
                "is_vulnerable": True,
                "confidence": 0.95,
                "severity": "high",
                "code_locations": ["payment.teal:23-45"],
                "mitigation": "Add require(Txn.fee() <= MAX_FEE)"
            }
        }
    )

    name: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Standardized vulnerability name (CWE/SANS format)",
        examples=["Unchecked Rekey To", "Arbitrary Deletion"]
    )

    description: str = Field(
        ...,
        min_length=20,
        description="Technical explanation with code references",
        examples=["The contract checks rekey_to == Global.zero_address() at line 42"]
    )

    is_vulnerable: bool = Field(
        ...,
        description="Final vulnerability determination"
    )

    confidence: float = Field(
        0.8,
        ge=0.0,
        le=1.0,
        description="Assessment confidence score (0=low, 1=high)"
    )

    severity: Optional[VulnerabilitySeverity] = Field(
        None,
        description="Risk severity level"
    )

    code_locations: list[str] = Field(
        [],
        description="Code locations (file:line) related to the finding",
        examples=[["contract.teal:42"]]
    )

    mitigation: Optional[str] = Field(
        None,
        description="Recommended fix if vulnerable",
        examples=["Add require(Txn.sender == creator)"]
    )

    """"@field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not re.match(r'^[A-Za-z][A-Za-z0-9_ ]+$', v):
            raise ValueError("Name must follow CWE naming conventions")
        return v.title()

    @field_validator('description')
    @classmethod
    def validate_description(cls, v: str, info) -> str:
        if info.data.get('name') and info.data['name'].lower() not in v.lower():
            raise ValueError("Description must reference the vulnerability name")
        if len(v.split()) < 10:
            raise ValueError("Description must be detailed (min 10 words)")
        return v

    @field_validator('confidence')
    @classmethod
    def validate_confidence(cls, v: float, info) -> float:
        if 'is_vulnerable' in info.data:
            if not info.data['is_vulnerable'] and v > 0.3:
                raise ValueError("Confidence too high for non-vulnerable case")
            if info.data['is_vulnerable'] and v < 0.7:
                raise ValueError("Confidence too low for vulnerable case")
        return round(v, 2)

    @model_validator(mode='after')
    def validate_mitigation_required(self) -> 'BoolVulnerability':
        if self.is_vulnerable and not self.mitigation:
            raise ValueError("Mitigation required for vulnerable findings")
        return self"""

    def to_markdown(self) -> str:
        """Generate audit-ready markdown report"""
        status = ("✅ Secure" if not self.is_vulnerable
                  else f"❌ Vulnerable ({self.severity.value})")
        return f"""
### {self.name}
**Status**: {status}  
**Confidence**: {self.confidence:.0%}  
**Locations**: {', '.join(self.code_locations) or 'N/A'}

**Analysis**:  
{self.description}

{"**Mitigation**: " + self.mitigation if self.mitigation else ""}
"""


class BoolVulnerability2(BaseModel):
    """
    Enhanced vulnerability assessment model with strict validation.
    Maintains original fields while adding robust type safety.
    """
    vulnerability_name: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="Standardized name of the vulnerability being tested",
    )

    description: str = Field(
        ...,
        min_length=20,
        description="Technical analysis of the code",
    )

    status: Literal["vulnerable", "not vulnerable"] = Field(
        ...,
        description="Binary assessment outcome - must be either 'vulnerable' or 'not vulnerable'"
    )